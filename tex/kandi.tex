\documentclass[12pt,a4paper]{article}
\usepackage[utf8]{inputenc}
\usepackage[finnish]{babel}
\usepackage{setspace}
%\usepackage{parskip}
\usepackage{amssymb}
\usepackage{wasysym}
%\usepackage{amsmath}
\usepackage{graphicx}
\usepackage{subcaption}
\usepackage{fancyhdr}
\usepackage[top=1in, bottom=1in, left=1in, right=1in]{geometry}
\usepackage{float}
\usepackage[section]{placeins}
\usepackage[nottoc,notlot,notlof]{tocbibind}
\usepackage{fixltx2e}
\usepackage{pdfpages}

\usepackage{titlesec}
\titleclass{\section}{top}
\newcommand\sectionbreak{\clearpage}
\titleformat*{\section}{\Huge\bfseries}
\titleformat*{\subsection}{\Large\bfseries}
\titleformat*{\subsubsection}{\large\bfseries}

%\usepackage[numbered,autolinebreaks,useliterate]{mcode}

\usepackage{siunitx}\sisetup{per=frac} % SI-yksiköitä.
%\usepackage{supertabular} % jos tarttee isoja taulukoita

\usepackage{hyperref}
\hypersetup{pdfborder={0 0 0}}
\onehalfspacing
\cfoot{}
\setlength{\parindent}{0pt}
\newcommand{\yt}{\texttt{yt}}

% pythonjutut
\usepackage{color}
\usepackage{listings}
\usepackage{setspace}

\definecolor{Code}{rgb}{0,0,0}
\definecolor{Decorators}{rgb}{0.5,0.5,0.5}
\definecolor{Numbers}{rgb}{0.5,0,0}
\definecolor{MatchingBrackets}{rgb}{0.25,0.5,0.5}
\definecolor{Keywords}{rgb}{0,0,1}
\definecolor{self}{rgb}{0,0,0}
\definecolor{Strings}{rgb}{0,0.63,0}
\definecolor{Comments}{rgb}{0,0.63,1}
\definecolor{Backquotes}{rgb}{0,0,0}
\definecolor{Classname}{rgb}{0,0,0}
\definecolor{FunctionName}{rgb}{0,0,0}
\definecolor{Operators}{rgb}{0,0,0}
\definecolor{Background}{rgb}{0.98,0.98,0.98}

\lstset{
  literate={ö}{{\"o}}1
           {ä}{{\"a}}1
           {ü}{{\"u}}1
}
\lstdefinestyle{python}{
numbers=left,
numberstyle=\footnotesize,
numbersep=1em,
xleftmargin=1em,
framextopmargin=2em,
framexbottommargin=2em,
showspaces=false,
showtabs=false,
showstringspaces=false,
frame=l,
tabsize=4,
% Basic
basicstyle=\ttfamily\small\setstretch{1},
backgroundcolor=\color{Background},
language=Python,
% Comments
commentstyle=\color{Comments}\slshape,
% Strings
stringstyle=\color{Strings},
morecomment=[s][\color{Strings}]{"""}{"""},
morecomment=[s][\color{Strings}]{'''}{'''},
% keywords
morekeywords={import,from,class,def,for,while,if,is,in,elif,else,not,and,or,print,break,continue,return,True,False,None,access,as,,del,except,exec,finally,global,import,lambda,pass,print,raise,try,assert},
keywordstyle={\color{Keywords}\bfseries},
% additional keywords
morekeywords={[2]@invariant},
keywordstyle={[2]\color{Decorators}\slshape},
emph={self},
emphstyle={\color{self}\slshape},
breaklines=true,
breakatwhitespace=true
postbreak=\raisebox{0ex}[0ex][0ex]{\ensuremath{\color{red}\hookrightarrow\space}}
}
%\renewcommand{\lstlistingname}{Uusinimi} %TODO mieti tämä

%\addtocontents{toc}{\protect\thispagestyle{empty}}

\begin{document}

\includepdf[fitpaper]{../kansilehti/kansi.pdf}

% Sisällysluettelo
\newpage
\tableofcontents
\thispagestyle{empty}
\newpage
\setcounter{page}{1}
\parskip=1em \advance\parskip by 0pt plus 2pt
\pagestyle{fancy}
\cfoot{\thepage}

%%%%%%%%%%%%%%% Oleellinen sisältö alkaa%%%%%%%%%%%%%%%
\section{Johdanto}
Simulaatiot ovat tärkeä osa tähtitieteen tutkimusta. Niiden avulla voidaan muun muassa tutkia kohteiden hyvin pitkän aikavälin kehitystä sekä tutkia sellaisiakin kohteita, joista ei vielä ole kattavaa havaintoaineistoa. Samoin voidaan testata teorioiden toimivuutta vertaamalla tietyillä alkuehdoilla ja mallilla saatuja tuloksia havaintoihin.

Eräs paljon käytetty simulaatiotyyppi ovat AMR-simulaatiot, joissa simuloitava alue katetaan päällekkäisillä hiloilla, joiden tiheydet vaihtelevat. Näin joitakin osia simulaatiosta voidaan laskea ympäristöään suuremmalla tarkkuudella, jolloin kiinnostavat alueet saadaan simuloiduksi halutulla tarkkuudella ilman, että laskentatehoa käytetään tarpeettoman paljon vähemmän kiinnostavien alueiden laskemiseen. Eräs esimerkki AMR-koodista on Enzo, joka tukee muun muassa hydrodynamiikkaa, kaasupilvien kemiaa ja säteilynkuljetusta sopien näin ollen hyvin astrofysikaalisten ongelmien ratkaisemiseen. \cite{enzo}

Jotta simulaatioiden tuloksia voidaan hyödyntää, täytyy data redusoida jotenkin. Tässä hyö\-dyl\-li\-nen työkalu ovat erilaiset visualisaatiot. Hyvin suunniteltu ja toteutettu plotti välittää tutkittavasta datasta oleellisen tiedon nopeasti ja helppolukuisesti. Tulosten visualisointi on kuitenkin tavallisesti aikaavievää ja vaatii kattavaa ymmärrystä simulaatiodatasta, sillä datasta on löydettävä oikeat alueet ja ne on osattava syöttää jollekin plottaustyökalulle oikeassa muodossa ja oikeissa yksiköissä.

Tätä työtä helpottamaan on kuitenkin kehitetty \yt, joka on avoimen lähdekoodin Python-paketti, joka abstrahoi simulaatiodatan helposti ymmärrettävään muotoon. Käyttäjän ei esimerkiksi tarvitse huolehtia hiloista tai partikkeleista eikä tietää, missä tiedostossa mikäkin osa datasta on tallennettuna, vaan käyttäjä voi suoraan antaa haluamansa alueen sijainnin ja koon esimerkiksi kiloparsekeissa. \yt :n vahvuuksiin kuuluu myös se, että sitä voidaan käyttää useiden eri simulaatiokoodien kanssa. Lisäksi se tukee rinnakkaislaskentaa \texttt{mpi4py}-moduulia käyttäen ja mahdollistaa visualisoinnin upottamisen simulaatiokoodiin, jolloin visualisointeja voidaan tallentaa lähes mielivaltaisen usein. \cite{yt}

Tälläinen työkalu on äärimmäisen hyödyllinen, sillä se helpottaa ja nopeuttaa visualisaatioiden luomista, jolloin tutkijat voivat keskittyä entistä enemmän varsinaiseen tieteeseen. Lisäksi koska \yt :n lähdekoodi on avointa, voidaan havaitut ongelmat ja puutteet korjata hyvinkin nopeasti ja sitä voi muokata ja laajentaa itse paremmin tarpeisiinsa sopivaksi.

Tässä työssä esitellään pääpiirteet sekä Enzosta että \yt :stä ja annetaan esimerkkejä \yt :n soveltamisesta Enzo-dataan. Esimerkkiskriptit on pyritty valitsemaan siten, että ne tuovat mahdollisimman hyvin esiin \yt :n ominaisuuksia ja ne ovat helposti laajennettavissa ja sovellettavissa. Lisäksi esitellään esimerkkinä käytettävä data ja sen taustat ja eritellään \yt :n lähdekoodiin monen kuvaajan plottien luomiseen käytettävän työkalun parantamiseksi tehdyt muutokset.

\section{Enzo}
Enzo on astrofysikaalisten fluidien simulointiin käytettävä ilmainen ja avoin simulaatiokoodi, joka on suunniteltu kosmologisten rakenteiden simulointiin. Se tukee muun muassa hydrodynamiikkaa, ideaalista ja epäideaalista magnetohydrodynamiikkaa, N kappaleen simulaatioita, kaasupilvien kemiaa, säteilynkuljetusta, tähtien syntyä sekä maailmankaikkeuden laajenemista. \cite{enzo}

Enzo hyödyntää mukautuvaa hilantihennystä (\textit{Adaptive Mesh Refinement}, AMR), joka mahdollistaa aika- ja paikkaresoluution kasvattamisen simulaation kiinnostavilla alueilla. Tämä on tärkeää, sillä usein melko pienellä alueella tarvitaan suurta resoluutiota, mutta koko simulaation ajaminen näin suurella tarkkuudella veisi kohtuuttoman paljon aikaa. Kullekin paikalle valitaan sopiva resoluutio automaattisesti käyttäjän määrittelemien ehtojen mukaan. \cite{enzo}

\subsection{Hila}
Simuloitava alue katetaan kokonaan hilalla, jonka tiheys valitaan sellaiseksi, että saavutetaan pienin haluttava resoluutio. Tämä niinkutsuttu juurihila toimii juurena muiden hilojen muodostamalle hierarkialle, joka muodostuu, kun juurihilasta valitaan alueita simuloitavaksi korkeammalla resoluutiolla.\cite{enzo}
	
Kaikki hilat ovat karteesisia ja suorakulmaisia. Alueille, joilla tarvitaan esimerkiksi suuremman tiheyden takia korkeampaa resoluutiota, asetetaan juurihilan kanssa päällekkäin toinen, hienompi hila. Näitä sisäkkäisiä hiloja voi tarvittaessa olla teoriassa mielivaltaisen monta. Kuvassa \ref{fig:enzogrid} on selvästi nähtävillä hilojen mukauttaminen tutkittavaan alueeseen: tiheillä tai muuten kiinnostavilla alueilla käytetään pienempiä ja tiheämpiä hiloja kuin muualla. \cite{enzo} %TODO oikeasti mielivaltaisen monta?
%Alueet, joilla käytetään suurempaa resoluutiota, valitaan siten, että niiden kaikki tahkot ovat päällekäin jonkin matalamman resoluution hilan tahkojen kanssa. 

\begin{figure}
   \centering
   \begin{subfigure}[b]{0.45\textwidth}
       \includegraphics[height=7.9cm]{../kuvat/amr-grid.png}
   \end{subfigure}
   \begin{subfigure}[b]{0.45\textwidth}
       \includegraphics[height=7.9cm]{../kuvat/amr-nogrid.png}
   \end{subfigure}
   \caption{Läpileikkaus $100$ pc$^2$ alueesta Enzo-simulaatiosta (julkaisua Regan et al. 2015 varten), jonka hilojen rajat näkyvillä (vasen kuva) sekä ilman niitä (oikea kuva). Tiheämmillä alueilla solut ovat pienempiä. Resoluution heikentyminen simulaation reuna-alueilla sijaitsevissa suuremmissa ja harvemmissa hiloissa on selvästi nähtävissä oikeanpuoleisessa kuvassa.}\label{fig:enzogrid} %TODO onko tuossa Regan et al. 2015 mitään järkeä?
\end{figure}
	
Kullakin hilalla juurihilaa lukuun ottamatta on vanhempi, joka sisältää hilan kokonaan. Yhdellä hilalla voi olla useita lapsia, mutta aina vain yksi vanhempi. Näin hilat muodostavat puumaisen rakenteen. Tavallisesta puita koskevasta nimeämiskäytännöstä poiketen sisaruksiksi kutsutaan kaikkia niitä hiloja, joiden resoluutio on sama eli ne sijaitsevat puussa samalla tasolla. \cite{enzo}
	
Hienompia hiloja luotaessa valitaan hilan solujen koko siten, että hila rajoittuu reunoistaan vanhempansa solujen tahkoihin. Lisäksi solun vanhemman sivun pituuden tulee olla jokin monikerta solun sivun pituudesta. \cite{enzo}

Kukin hila koostuu varsinaisen datan tallettavien aktiivisten vyöhykkeiden (\textit{active zone}) lisäksi haamuvyöhykkeistä (\textit{ghost zone}), joita käytetään laskennassa tarvittavien aktiivisten vyöhykkeiden arvojen päivittämiseen tarvittavien naapurisolujen varastoimiseen väliaikaisesti. Hydrodynamiikkaa varten haamuvyöhykkeitä on kolme kerrosta kullakin aktiivisen vyöhykkeen tahkolla. Haamuvyöhykkeiden arvot saadaan interpoloimalla hilan vanhemmasta tai kopioimalla sisaruksista.\cite{arxivenzo, enzo}

\subsection{Numeerinen ratkaiseminen}
Enzo tarkastelee kutakin hilaa omana ongelmanaan ratkaisten tarvittavat yhtälöt kullekin hilalle erikseen käyttäen reunaehtoina haamuvyöhykkeistä saatavia arvoja. Aluksi määritetään halutun tarkkuuden saavuttamiseksi tarvittava aika-askel kullekin puun tasolle. Tämän jälkeen aletaan tasoja käydä läpi W-syklin mukaisesti (kuva \ref{fig:w-cycle}). \cite{enzo} %TODO W-syklin mukaisesti?

W-syklissä kunkin tason kaikille hiloille lasketaan aluksi niiden tila yhden aika-askeleen kuluttua. Laskeminen aloitetaan juurihilasta ja se etenee tasoittain, kunnes kaikki AMR-puun lehdet on käsitelty. Seuraavaksi puun alimmalla tasolla olevia hiloja edistetään niin monta aika-askelta kuin tarvitaan, jotta saavutetaan ylempi taso, jonka hiloja edistetään myös yhden aika-askeleen verran. Tämän jälkeen alimman tason hiloja edistetään taas, kunnes ylempi taso on jälleen saavutettu. \cite{enzo}

Hilojen edistämistä jatketaan näin, edistäen aina tason $l$ hiloja, kunnes ne saavuttavat tason $l-1$ hilat, jolloin tason $l-1$ hiloja edistetään jälleen yhden aika-askeleen verran. Näin seuraava aika-askel lasketaan aina sille tasolle, jolla aikaa simulaation alusta on kulunut vähiten. Kun hiloja on edistetty niin pitkälle, että on jälleen aika edistää tason 0 hilaa, sykli alkaa alusta. \cite{enzo}

\begin{figure}
   \centering
   \includegraphics[width=\textwidth]{../kuvat/W-cycle.png}
   \caption{Vasemmalla kolmitasoinen hierarkia hiloja ja oikealla niiden läpikäyntijärjestys W-syklissä ja aika-askeleiden pituudet kun oletetaan, että tason $l+1$ aika-askel on puolet tason $l$ aika-askeleen pituudesta ja tason $0$ aika-askeleen pituus on $t$. Katkoviivalla on erotettu vaiheet, joiden jälkeen kunkin tason hilat ovat edenneet ajan $t$ verran eli ollaan jälleen alkutilannetta vastaavassa tilanteessa, jolloin sykli alkaa uudelleen.}\label{fig:w-cycle}
\end{figure}

%Siksi AMR-simulaatioissa 

%Esimerkiksi kuvassa \ref{fig:enzogrid} nähdään, kuinka tiheämmillä alueilla käytetään pienempiä 


\section{\yt}
\yt\ on avoimen lähdekoodin Python-paketti, joka mahdollistaa simulaatiotulosten helpon lukemisen, analysoinnin ja visualisoinnin. Kehitystyön alkuvaiheessa se sopi käytettä\-väksi vain Enzo-simulaatioiden kanssa, mutta nykyään sillä voidaan suoraan lukea sekä muiden AMR-simulaatioiden (kuten RAMSES tai BoxLib) että N kappaleen simulaatioiden (esimerkiksi Gadget) tuloksia. \cite{yt} %TODO N kappaleen vai N-kappaleen???

\subsection{Käyttäjän ja simulaatiodatan välinen rajapinta}
\yt\ abstrahoi hyvin voimakkaasti lukemansa datan, jolloin käyttäjä voi keksittyä fysikaalisiin rakenteisiin, joita simulaatio edustaa. Kun käyttäjä on ladannut simulaatiodatan, voi siitä tarkastella esimerkiksi pallomaista aluetta antamalla alueen keskustan koordinaatit ja pallon säteen ilman, että käyttäjän tarvitsee esimerkiksi etsiä niitä hiloja, jotka kattavat alueen parhaalla mahdollisella resoluutiolla tai tietää, missä tiedostoissa data on tallennettuna. Lisäksi \yt\ huolehtii yksikkömuunnoksista. \cite{yt}

Koska dataa käsitellään abstrakteina olioina, voidaan samaa ohjelmaa käyttää myös eri simulaatioista saadun datan kanssa vaihtamalla luettavaa datasettiä. Esimerkiksi alla oleva koodisegmentti lataa sijainnissa ''data'' olevan simulaation muistiin ja plottaa sen keskeltä sivultaan 500 kpc olevan alueen poikkileikkauksen tiheyden ja tallentaa sen. Ohjelma ei ota kantaa luettavan datan muotoon, ja onkin siksi helposti käytettävissä minkä tahansa \yt :n tukeman datasetin kanssa ainoastaan vaihtamalla datasettiä ladattaessa annettavaksi parametriksi halutun datan sijainti \cite{yt, cookbook}.

\begin{minipage}{\textwidth}
\lstset{style=python}
\begin{lstlisting}
import yt
dataset = yt.load("data")
plot = yt.SlicePlot(dataset, "x", "density", width = (500, "kpc"))
plot.save("slice.png")
\end{lstlisting}
\end{minipage}

Simulaatiodatassa olevien tietojen lisäksi \yt\ pystyy laskemaan datasta myös monia muita suureita kuten vaikkapa kulmaliikemäärän, maksimi- ja minimiarvoja sekä niiden sijainteja tai massakeskipisteen sijainnin. Lisäksi käyttäjän on mahdollista luoda omia kenttiä. Alla on \yt :n dokumentaatiosta\footnote{\url{http://yt-project.org/doc/developing/creating_derived_fields.html}} mukailtu esimerkki koodinpätkästä, jolla lisättäisiin paine \yt :n tuntemien kenttien joukkoon. Uudelle kentälle määritellään nimen ja funktion lisäksi myös yksikkö. \cite{yt, derivedfields}

\begin{minipage}{\textwidth}
\lstset{style=python}
\begin{lstlisting}
def _pressure(field, data):
    return (data.ds.gamma - 1.0) * data["density"] * data["thermal_energy"]
yt.add_field("pressure", function=_pressure, units="dyne/cm**2")
\end{lstlisting}%TODO gamma? specific heat ratio? keksi parempi kenttä? vaihda ainakin yksiköt
\end{minipage}

Laskettujen suureiden laskemisen jälkeen \yt\ tarjoaa laajan valikoiman työkaluja tulosten visualisointiin. Aiemmin esiteltyjen poikkileikkausten lisäksi \yt :llä voi luoda muun muassa erilaisia profiileja, painottamattomia tai painotettuja projektioita tai 3D-renderöintejä. \cite{yt}

\subsection{Rinnakkaistaminen}
Usein visualisoitavaa dataa on hyvin paljon ja tietokoneiden kehittyessä sen määrä edelleen lisääntyy, jolloin rinnakkaislaskennan käyttö myös datan analysoinnissa tulee tärke\-äm\-mäksi ja tärkeämmäksi. \yt\ käyttää \texttt{mpi4py}-moduulia mahdollistaakseen datan rinnakkaisen käsittelyn niissä tehtävissä, jotka ovat helposti rinnakkaistettavissa. Tälläisiä ovat esimerkiksi tehtävät, joissa simuloitava alue voidaan jakaa eri prosessorien kesken. Muun muassa projistointi on mahdollista toteuttaa siten, että kukin prosessori laskee tietyn joukon näkösäteitä, jotka lopuksi yhdistetään yhdeksi plotiksi. \cite{yt}

Käyttäjä voi ottaa rinnakkaistuksen käyttöön ohjelmassaan yksinkertaisesti lisäämällä ohjelmansa alkuun rivin \texttt{yt.enable\_parallelism()}. Lisäksi ohjelman suorittamiseen on luonnollisesti käytettävä \texttt{mpirun}-komentoa. Tällöin \yt\ osaa rinnakkaistaa esimerkiksi projektioiden, poikkileikkausten, profiilien ja 3D-renderöintien luonnin sekä halojen etsimisen. Tarvittaessa joitain operaatioita voidaan suorittaa sarjallisesti esimerkiksi tarkastamalla funktion \texttt{yt.is\_root()} palauttama arvo, joka palauttaa arvon \texttt{True} jos kutsuvalla prosessorilla on MPI rank 0, muuten \texttt{False}. \cite{yt, parallel}

\yt\ pystyy käsittelemään myös useita datasettejä tai objekteja rinnakkain. Käyttämällä jokerimerkkejä kuten \texttt{*} ja \texttt{?} dataa ladattaessa voidaan kerralla valita useita datasettejä tai objekteja käsiteltäväksi rinnakkain. Tämän jälkeen ne voidaan käydä läpi käyttäen \texttt{piter()}-funktiota, joka jakaa käsiteltävät oliot prosessorien kesken. \cite{parallel}

\subsection{Visualisoinnin upottaminen simulaatiokoodiin}
\begin{sloppypar}Vaikka simulaation tila voidaan tarvittaessa tallentaa vaikka jokaisen aika-askeleen jälkeen, on prosessi hidas ja vaatii suuria tai pitkäkestoisia simulaatioita ajettaessa kohtuuttoman paljon levytilaa. Python/C API (ohjelmointirajapinta, \textit{Application programming interface}) mahdollistaa muistissa olevan datan antamisen Python-tulkille simulaation sisällä. \yt\ puolestaan tarjoaa API:n jolla simulaation informaatio voidaan välittää analyysipaketille ja \yt :tä voidaan käyttää ajossa olevan simulaation analysointiin. \cite{yt}
\end{sloppypar}

Kun simulaation outputteja ei tarvitse tallentaa visualisointia varten, voidaan kuvia tai plotteja tallentaa huomattavasti useammin ja saavutetaan huomattavasti parempi tarvittavan tallennustilan ja tallennetun hyödyllisen informaation määrän suhde, sillä simulaation outputin koko liikkuu usein gigatavujen luokassa kun taas esimerkiksi kuvat ovat vain joitain kymmeniä tai satoja kilotavuja. Tyypillisesti dataa redusoidaan voimakkaasti joka tapauksessa, joten alkuperäisen outputin tallentaminen ei välttämättä ole mielekästä niin usein kuin esimerkiksi sulavan animaation tuottamiseksi on tarpeen. \cite{yt}

\subsection{Kuvien luominen}
\yt\ piilottaa paljon plottien luomiseen tarvittavista esimerkiksi datan tallennusmuotoon tai numeeristen arvojen väreiksi muuttamiseen liittyvistä toimista. On kuitenkin ohjelman suorituskyvyn ja tuotettujen kuvien ymmärtämisen kannalta tärkeää ymmärtää jonkin verran myös \yt :n toimintaa. Alla on eritelty muutamien kuvien luomisen mekaniikkaa hieman käyttäjälle näytettävää pintaa syvemmältä.

\subsubsection{Läpileikkaukset ja projektiot}
Läpileikkausten ja projektioiden luominen \yt :llä on pääpiirteissään melko samanlaista, tärkeimpänä erona käsiteltävän data-alueen laajuus. Läpi\-leikkausten luominen on tyypillisesti melko nopeaa, sillä niiden tekemiseksi täytyy käydä läpi vain ohut viipale datasetistä. Plotti luodaan hakemalla ensin tarvittava data datasetistä suurimmalla mahdollisella resoluutiolla \texttt{Fixed\-Resolution\-Buffer}-luokkaan (FRB), josta muodostetaan kuva käyttäjän määrittelemästä kohdasta. Samaa FRB:tä voidaan käyttää useiden kuvien renderöintiin mikäli kuvaa halutaan esimerkiksi zoomata tai panoroida. Tämä nopeuttaa kuvien luomista hieman. \cite{sliceproj}

\begin{sloppypar}Projektioiden luominen \yt :llä onnistuu pääpiirteissään samalla tavoin kuin läpi\-leik\-kaus\-ten\-kin. Projektiota luotaessa täytyy kuitenkin käydä läpi koko näkösäde kutakin lopullisen kuvan pikseliä kohden, joten niiden luominen on tyypillisesti hieman hitaampaa kuin läpi\-leikkausten. Ne tuovat kuitenkin usein läpileikkauksia paremmin esiin näkösäteen suunnassa laajempia rakenteita. Sekä läpileikkauksia että projektioita voi tehdä myös muissa kuin simulaation koordinattiakselien suunnissa käyttäen \texttt{OffAxisSlicePlot}- ja \texttt{OffAxisProjectionPlot}-luokkia. \cite{sliceproj}
\end{sloppypar}

\begin{sloppypar}Projektiota luotaessa pikselien arvot voidaan määrittää usealla eri tavalla. Yleisimpiä näistä ovat painotettu ja painottamaton integrointi, jotka määritetään asettamalla \texttt{method=integrate}. Mikäli \texttt{weight\_field}-parametria ei ole asetettu, lasketaan painottamaton keskiarvo yhtälön \ref{equ:unweighted} mukaisesti integroimalla haluttu kenttä $f(x)$ näkösäteen $\hat{n}$ suunnassa tutkittavan alueen yli. Tällöin projisoidun kentän yksikkö on alkuperäisen kentän yksikkö kerrottuna pituusyksiköllä. Mikäli \texttt{weight\_field} on määritelty, lasketaan kentän painotettu keskiarvo yhtälön \ref{equ:weighted} mukaisesti. Tällöin myös yksikkö säilyy projisoinnissa samana. \cite{sliceproj}
\begin{equation}\label{equ:unweighted}
	g(X) = {\int\ {f(x)\hat{n}\cdot{dx}}}
\end{equation}
\begin{equation}\label{equ:weighted}
	g(X) = \frac{\int\ {f(x)w(x)\hat{n}\cdot{dx}}}{\int\ {w(x)\hat{n}\cdot{dx}}}
\end{equation}
\end{sloppypar} 

Muita mahdollisia projisointitapoja ovat ovat \texttt{mip} ja \texttt{sum}. Näistä ensimmäinen valitsee projisoitavan kentän maksimiarvon kullakin näkösäteellä ja jälkimmäinen integroinnin sijaan summaa kentän arvot näkösäteellä ottamatta huomioon kuljetun polun pituutta. Siksi \texttt{sum} sopiikin käytettäväksi vain sellaisten gridien kanssa, joiden solut ovat vakiokokoisia, sillä muuten syntyvä kuva saattaa olla hyvin epäfysikaalinen. Kumpikin säilyttää alkuperäisen kentän yksiköt. \cite{sliceproj, projection}

\subsubsection{3D}
\yt\ tarjoaa myös mahdollisuuden kolmiulotteisten rakenteiden tarkastelemiseen tilavuusrenderöimällä. Kuten kaksiulotteisissakin ploteissa myös tilavuusrenderöinnissä voidaan käyttää mitä tahansa simulaatiodatan kenttää ja esimerkiksi katselusuuntaa kääntä\-mällä tai zoomaamalla voidaan simulaation kiinnostavia piirteitä tuoda esiin joissain tilanteissa havainnollisemmin kuin läpileikkauksilla tai projektioilla. \cite{volume}

Tilavuusrenderöintiä varten on ensin luotava color transfer function, jonka perusteella määritetään tarkasteltavan tilavuuden emissio ja absorptio kussakin RGBA-väri\-järjes\-telmän kaistassa. Täten color transfer function kertoo kunkin pisteen värin paikan funktiona siten, että $f(v) \rightarrow (r, g, b, a)$. Sen voi määrätä käyttäen mitä tahansa simulaation kenttä joko painottamattomana tai painotettuna toisella kentällä. \cite{volume}

Seuraavaksi luodaan \texttt{camera}-olio, jolloin datalohkot jaetaan kuvattavan alueen täysin kattaviin ''tiiliin'' (\textit{bricks}), joihin valitaan parhaan mahdollisen resoluution data jokaisesta pisteestä. Nämä tiilet järjestetään näkösäteen suunnassa takaa eteen, jotta ne on helppo käydä läpi siinä järjestyksessä, jossa silmään saapuva säde kohtaa ne. Seuraavaksi luodaan kuvatason kanssa yhdensuuntainen taso säteitä kuvattavan alueen perälle alkuarvolla nolla. Näitä säteitä liikutetaan kohti katsojaa ja pikselien arvot päivitetään kullakin askeleella. \cite{volume}

\begin{sloppypar}
Kullekin tiilelle lasketaan, mitkä säteet leikkaavat sen. Kustakin säteestä otetaan \texttt{sub\_samples}-parametrilla määrättävä määrä näytteitä (oletusarvoisesti 5) ja arvot näytteenottokohdissa lasketaan solun kärkien arvoista trilineaarisella interpoloinnilla. Tämän jälkeen kussakin pisteessä lasketaan transfer function arvo, jolloin saadaan emission $j$ ja absorption $\alpha$ voimakkuus kussakin kaistassa. Näiden perusteella kullekin pikselille lasketaan uusi arvo ottaen huomioon säteen kulkema matka. Pikselin uusi arvo $v^{n+1}$ kaistassa $i$ saadaan pikselin aiemman arvon $v^n$ perusteella yhtälöstä \ref{equ:3d}, jossa $\Delta s$ on säteen kulkema matka näytteenottopisteiden välillä.
\begin{equation}\label{equ:3d}
v^{n+1}_{i} =  j_{i}\Delta s + (1 - \alpha_{i}\Delta s )v^{n}_{i}
\end{equation}
\end{sloppypar}


\section{Supermassiiviset mustat aukot}
Tutkielmassa esiteltävät plotit on luotu John Reganin et al. supermassiivisten mustien aukkojen syntyä mallintavasta simulaatiodatasta. Simulaatio on ajettu käyttäen aiemmin esiteltyä Enzo-simulaatiokoodia. Sen tarkoituksena on tutkia, kuinka hyvin varhaisessa maailmankaikkeudessa voi syntyä havaintoja vastaavia supermassiivisia mustia aukkoja. Simulaatiossa tutkitaan mahdollisuutta kaasupilven romahtamiseen suoraan noin $10^4$ -- $10^6~ M_{\astrosun}$ massaiseksi mustaksi aukoksi vetymolekyylejä hajottavan Lyman-Werner -kaistassa säteilevän säteilylähteen läheisyydessä. \cite{rj}

\subsection{Havainnot}
Kvasaareista on toisistaan riippumattomia havaintoja jopa punasiirtymillä $z \gtrsim 6$, jotka vastaavat aikaa noin 0,9 miljardin vuoden sisällä maailmankaikkeuden synnystä. Näitä havaintoja on tehty muun muassa SDSS- sekä VIKING-datasta. Optisen alueen havainnoissa joudutaan rajoittumaan alueeseen $z \lesssim 6,4$, mutta lähi-infrapunassa on havaittu kohde jopa punasiirtymällä $z= 7,085$. \cite{fan, mortlock, venemans}

Kvasaarihavainnot osoittavat, että jo näillä varhaisilla punasiirtymillä on ollut olemassa supermassiivisia mustia aukkoja, joiden massa on luokkaa $10^9 ~M_{\astrosun}$. Tämä on yllättävää, sillä mustan aukon on kasvettava hyvin nopeasti tai synnyttävä melko suurena, jotta se ehtii saavuttaa näin suuren massan. Näiden varhaisten supermassiivisten mustien aukkojen synnyn selittäminen onkin haasteellista nykyisillä teoreettisilla malleilla. \cite{li}

\subsection{Eddingtonin luminositeetti}
Vaikka mustan aukon läheisyydessä olisi runsaasti ainetta, ei aukko voi kasvaa mielivaltaisen nopeasti. Kun aukkoon putoaa ainetta, aineen lepomassan energiasta jopa 40\%, tyypillisestikin noin 10\%, vapautuu säteilynä \cite{pringle}. Tästä aiheutuva säteilypaine vaikuttaa muihin kertymäkiekon hiukkasiin työntäen niitä kauemmas, jolloin aukkoon putoavan aineen määrä vähenee jälleen. \cite{bartelmann}

Alla olevassa käsittelyssä tutkitaan pelkästään elektronien tuntemia voimia. Mustaa aukkoa ympäröivä aine koostuu kuitenkin varhaisessa maailmankaikkeudessa lähinnä vetyplasmasta, jossa on elektronien lisäksi protoneja. Protonin vaikutusala Thomsonin sironnassa on kuitenkin elektroniin verrattuna noin 1836-kertaisesta massasta johtuen noin $\SI{3,2e6}{}$ kertaa pienempi kuin elektronin, joten protoneihin vaikuttava säteilynpaine on mitättömän pieni verrattuna elektroneihin vaikuttavaan. Coulombin voiman ansiosta elektronien tuntema säteilypaine välittyy kuitenkin myös protoneihin. Näin ollen kaasuun kohdistuvien voimien laskemiseksi tulee hiukkasen massana $m$ käyttää keskimääräistä massaa per elektroni, vetyplasman tapauksessa siis käytännössä protonin massaa. \cite{pringle}

Aukkoa ympäröivän aineen elektroneihin vaikuttaa säteilypaineen aiheuttama voima
\begin{equation}\label{sateilypaine}
	\vec{F}_R = \frac{L}{4 \pi R^2 c} \sigma_T \vec{e},
\end{equation}
joka työntää elektroneja kauemmas aukosta. Yhtälössä $L$ on aukon luminositeetti, $R$ elektronin etäisyys aukosta ja $\sigma_T$ elektronin vaikutusala Thomsonin sironnassa. Samalla aukon painovoima vetää niitä kohti aukkoa yhtälön \ref{gravitaatio} mukaisesti.
\begin{equation}\label{gravitaatio}
	\vec{F}_G = -\frac{GM_{BH}m_p}{R^2}\vec{e}
\end{equation}
Hiukkanen putoaa kohti aukkoa kun $|\vec{F}_G|>|\vec{F}_R|$. Kun oletetaan ionisoituneen aineen jakautuneen tasaisesti aukon ympärille ja aukon säteilevän pallosymmetrisesti, voidaan tästä ehdosta laskea luminositeetti, jolla säteilypaine on yhtä suuri kuin aukon painovoima, jolloin ainetta ei enää putoa aukkoon. Tällöin aukko on saavuttanut \textit{Eddingtonin luminositeetin}, jolle voidaan yhtälöiden \ref{sateilypaine} ja \ref{gravitaatio} avulla ratkaista yhtälön \ref{eddington} mukainen lauseke. \cite{pringle}
\begin{equation}\label{eddington}
	L_{Edd}=\frac{4 \pi GM_{BH}m_{p}}{\sigma_T}c
\end{equation}

Pallosymmetrisesti massaa keräävä musta aukko ei voi kasvaa Eddingtonin luminositeetin asettamaa rajaa nopeammin. On kuitenkin kehitetty joitakin malleja, joissa sopivilla kertymäkiekon ominaisuuksilla voidaan hetkellisesti saavuttaa esimerkiksi 100--200 -kertainen kasvunopeus Eddingtonin luminositeetin asettamaan ylärajaan verrattuna. Tämä on mahdollista, mikäli mustan aukon säteily kohdistuu hyvin pieneen avaruuskulmaan tai energiaa siirtyy muilla tavoilla. \cite{sadowski}

\subsection[Mustien aukkojen synty]{Supermassiivisten mustien aukkojen mahdolliset syntytavat}
Selkein tapa mustan aukon synnylle on syntyä tähden kehityksen lopputuotteena. Mikäli esimerkiksi massaltaan luokkaa 100--300~$M_{\astrosun}$ oleva populaation III tähti romahtaa mustaksi aukoksi punasiirtymällä $z \approx 20$, se voi ehtiä kasvaa supermassiiviseksi punasiirtymään $z\approx 7$ mennessä. Tämä edellyttää kuitenkin sitä, että saatavilla on riittävästi materiaa, jotta aukko voi kasvaa lähes koko ajan Eddingtonin luminositeetin asettamalla rajalla. \cite{whalen, volker}

Tämä on kuitenkin ongelmallista, sillä populaation III tähdet yleensä menettävät elinaikanaan kaasupilven, jossa ne ovat syntyneet. Lisäksi jotkin simulaatiot viittaavat siihen, että tyypillinen populaation III tähti oli massaltaan vain joitakin kymmeniä $M_{\astrosun}$, jolloin kasvaminen supermassiiviseksi tarkasteltavalla aikavälillä on vielä epätodennäköisempää. Lisäksi mustan aukon alettua kerätä materiaa, sen säteilemä ionisoiva säteily hajottaa entisestään aukkoa ympäröivää pilveä, jolloin kasvu rajoittuu murto-osaan Eddingtonin rajasta. \cite{whalen, alvarez, volker}

Mitä massiivisempi musta aukko on syntyessään, sitä hitaampi kasvu riittää selittämään havainnot. Romahtaminen suoraan mustaksi aukoksi vaatii kuitenkin sopivat olosuhteet, sillä tavallisesti kaasupilvi fragmentoituu ja syntyy yhden mustan aukon sijaan paljon pienempiä tähtiä. Fragmentoitumisessa syntyvien kohteiden koon määrää pilven Jeansin massa $M_J$, jolle pätee $M_J \propto T^{\frac{3}{2}}$ missä $T$ on kaasun kineettinen lämpötila. \cite{volker, rj, tape}

Ainoastaan mikäli kaasupilvi on tarpeeksi suuri ja kuuma, se voi romahtaa luokkaa $10^4\ M_{\astrosun}$ massaiseksi mustaksi aukoksi. Näin suuren aukon kasvaminen havaintoja vastaavaksi pystytään jo selittämään uskottavasti. Korkean lämpötilan ylläpitämiseksi pilven jäähtymisen on kuitenkin oltava hyvin tehotonta, eli pilvi ei saa sisältää metalleja, pölyä tai molekulaarista vetyä. \cite{volker, rj}

Varhaisessa maailmankaikkeudessa metalleja ja pölyä oli hyvin vähän, mutta molekulaarista vetyä voi kuitenkin syntyä tiheillä alueilla. Siksi jonkin prosessin onkin hajotettava vetymolekyylejä atomeiksi. Tämän voi tehdä esimerkiksi säteily Lyman-Werner -kaistassa (11,2--13,6 eV), joka virittää molekyylin elektronit korkeammille energiatasoille, jolloin molekyyli hajoaa takaisin atomeiksi eikä kaasun jäähtyminen tehostu niin paljon, että se fragmentoituisi tähdenmassaisiksi osiksi. \cite{rj}

\subsection{Tutkittava simulaatio}
LW-kaistan säteilyn vaikutusta varhaisiin kaasupilviin on tutkittu jo useissa julkaisuissa ja tulokset ovat vaikuttaneet lupaavilta, mutta aiemmissa simulaatioissa säteily on ollut isotrooppista. Tutkielman esimerkkidatana käyttämässäni John Reganin et al. simulaatiossa on tästä poiketen käytetty pistemäistä säteilylähdettä isotrooppisen LW-taustan sijaan. Tämä todennäköisesti vastaa aiempia simulaatioita paremmin todellisia olosuhteita. \cite{rj}

Tutkittava halo on peräisin aiemmin ajetuista simulaatioista. Niitä varten ajettiin ensin melko epätarkkoja pelkkää pimeää ainetta sisältäviä simulaatioita, joista poimittiin tiheimmät alueet punasiirtymällä $z=30$, joka vastaa noin kymmenen miljoonan vuoden ikäistä maailmankaikkeutta. Näillä alueilla ajettiin uudelleen alusta aloittaen tarkemmat simulaatiot, joissa myös hydronynamiikka otettiin huomioon. Datasta valittiin yksi halo, jonka romahtamista tutkittiin. Punasiirtymällä $z = 30$ halon massa oli noin $10^6~M_{\astrosun}$ ja punasiirtymään $z = 21$ mennessä se kasvoi noin massaan $\SI{6e7}{} M_{\astrosun}$. \cite{rj}

Simulaatiossa tutkittiin halon romahtamista kun 3 kpc päässä siitä on LW-kaistassa säteilevä kohde. Simulaatio ajettiin useita kertoja erilaisilla säteilyn voimakkuuksilla tarvittavan intensiteetin selvittämiseksi. Simulaation tulokset viittavat siihen, että noin $10^{54}$ fotonia/s vuo LW-kaistassa riittää vähentämään H$_2$ määrää riittävästi, jotta noin massaltaan luokkaa $10^5~M_{\astrosun}$ oleva kappale voi syntyä. Tätä pienemmillä vuon arvoilla syntyy vain noin $10^3~M_{\astrosun}$ massa, joka romahtaa H$_2$ vaikutuksesta Populaation III tähdeksi. \cite{rj}

\section{\yt :n sovelluksia}
Aloitin \yt :hen tutustumisen selaamalla dokumentaatiota sekä cookbookia\footnote{\url{http://yt-project.org/docs/3.1/cookbook/}} ja ensin kopioimalla ja sittemmin muokkaamalla siellä annettuja malliohjelmia käyttäen esimerkkidataa. Tutustuin tarkimmin poikkileikkauksiin, projektioihin ja 3D-renderöinteihin sekä muun muassa niiden akselien tekstien ja jaotuksen tai väriskaalojen muokkaamiseen. Lisäksi kokeilin \yt :n soveltamista animaatioiden tekemiseen.

Opittuani perusasiat aloin soveltaa niitä tutkimusryhmämme tuottamaan dataan kaasupilven romahtamista suoraan mustaksi aukoksi koskevista simulaatioista (Regan et al. 2015). Samalla otin selvää \yt :n tarjoamista mahdollisuuksista usean plotin yhdistämiseksi yhteen kuvaan. Kun samaan kuvaan halutaan useantyyppisiä kuvia, voidaan käyttää \texttt{eps\_writer}-luokkaa. Sen tarjoama tuki profiileille oli kuitenkin puutteellinen, joten jouduin myös parantelemaan \yt :n lähdekoodia.

\subsection{Läpileikkaukset}
Aloitin tutustumalla \yt :n yksinkertaisimpiin plotteihin aloittaen läpileikkauksista. Niitä voidaan käyttää yksittäisinä näyttämään jokin alue simulaatiosta tai niitä voidaan renderöidä useita ja koostaa niistä animaatio. Esimerkiksi listing \ref{koodi:flythrough} lukee annetun datasetin ja tallentaa läpileikkauksen tiheyksistä simulaation tiheimmän kohdan ympäriltä sadasta kohdasta liikkuen z-akselia pitkin 1 kpc matkan. Esimerkissä tarkastellaan kohdetta koordinaattiakselin suunnasta, mutta läpileikkauksia voidaan haluttaessa luoda mielivaltaisesta suunnasta \cite{sliceproj}.

Lisäksi plotin väripalkin alueeksi asetetaan \SI{3e-26}{} -- \SI{2.5e-25}{\gram\per\cubic\centi\metre} (noin 0,01--0,11 vetyatomia kuutiosenttimetrissä)
ja colormapiksi hot\footnote{\url{http://yt-project.org/doc/visualizing/colormaps/}}. Lisäksi akseleilla käytettävän fontin kokoa kasvatetaan ja lopullinen kuva tallennetaan juoksevaa numerointia käyttäen. Neljä sadasta tuloksena saatavista plotista tasaisin välein valittua läpileikkausta on nähtävissä kuvassa \ref{fig:flythrough}.

\begin{minipage}{\linewidth}
\lstinputlisting[style=python, caption={Python-ohjelma, joka tallentaa 100 esimerkiksi animoitavaksi sopivaa framea, joissa sivultaan 3 kpc oleva läpileikkaus liikkuu simulaation z-akselin suunnassa läpi simulaation tiheimmän kohdan.}, label={koodi:flythrough}]{../python/flythrough.py}
\end{minipage}

\begin{figure}
   \centering
   \begin{subfigure}[b]{0.48\textwidth}
       \includegraphics[width=\textwidth]{../kuvat/flythrough/0000.png}
   \end{subfigure}
   \begin{subfigure}[b]{0.48\textwidth}
       \includegraphics[width=\textwidth]{../kuvat/flythrough/0032.png}
   \end{subfigure}
   \begin{subfigure}[b]{0.48\textwidth}
       \includegraphics[width=\textwidth]{../kuvat/flythrough/0066.png}
   \end{subfigure}
   \begin{subfigure}[b]{0.48\textwidth}
       \includegraphics[width=\textwidth]{../kuvat/flythrough/0099.png}
   \end{subfigure}
   \caption{Neljä listingissä \ref{koodi:flythrough} esitetyn koodin tallentamista kuvista, kun se ajetaan julkaisua Regan et al. 2015 varten lasketulla datalla. Alueessa edetään syvemmälle riveittäin vasemmalta oikealle.}\label{fig:flythrough}
\end{figure}

\subsection{Projektiot}
%TODO kirjoita uusi alku

Listingissä \ref{koodi:projection} on esitetty yksinkertaisen projektion tallentava skripti. Se käyttää listingin \ref{koodi:flythrough} kanssa samaa simulaatiodataa, josta luodaan yksi projektio integroimalla $z$-akselin suuntaisen näkösäteen suunnassa. Skriptin tuottama kuva on nähtävissä kuvassa \ref{fig:projection}. Vertaamalla tätä kuvan \ref{fig:flythrough} läpileikkauksiin huomataan, että projisointi kadottaa näkösäteen suunnassa pienet yksityiskohdat, mutta projektiosta saa paremman kuvan suuremman skaalan rakenteista. Myös yksiköiden huomataan poikkeavan toisistaan, sillä projektiota luotaessa käytettiin painottamatonta integrointia.

%TODO ehkä myös jotain vähän lisää nyt kun osa on siirretty pois?

\begin{minipage}{\linewidth}
\lstinputlisting[style=python, caption={Yksinkertaisen projektion luomiseen soveltuva ohjelma. Käytetty alue datassa on sama kuin listingissä \ref{koodi:flythrough}, mutta useiden läpileikkausten sijaan luodaan yksi projektio.}, label={koodi:projection}]{../python/projection.py}
\end{minipage}

\begin{figure}
   \centering
   \includegraphics[width=.7\textwidth]{../kuvat/projection.png}
   \caption{Listingin \ref{koodi:projection} luoma projektio. Verrattuna kuvan \ref{fig:flythrough} läpileikkauksiin nähdään vähemmän yksityiskohtia, mutta projektio antaa paremman kokonaiskuvan koko alueesta kerralla.} \label{fig:projection}
\end{figure}

%TODO tällä haavaa päätelmiä on sekaisin omassa työssä

\subsection{3D}
Tilavuusrenderöinnit tuovat usein tutkittavan kohteen kolmiulotteisen rakenteen esiin projektioita ja läpileikkauksia intuitiivisemmin. Yksittäiset kuvat saattavat kuitenkin olla vaikeasti tulkittavia, sillä kohteiden etäisyyttä katsojasta on usein vaikeaa hahmottaa. Kuvista ja etenkin animaatioista on kuitenkin mahdollista saada erittäin näyttäviä. 

Liitteessä \ref{koodi:volume-spiraali} on esitetty skripti, jolla voidaan luoda framet animaatioon, jossa kamera sekä kiertää kohdetta että zoomaa sisään. Datan lataamisen jälkeen riveillä 10--13 etsitään datan tiheimmästä kohdasta korkeintaan 0,5 kpc päässä oleva paikka, jossa molekulaarisen vedyn osuus kaikesta vedystä on suurin hyödyntämällä \yt :n tarjoamia \texttt{find\_max}- ja \texttt{max\_location}-funktioita. Tämän jälkeen riveillä 16--19 määrätään tutkittavaksi alueeksi säteeltään 1 kpc pallo löydetyn suurimman molekulaarisen vedyn pitoisuuden kohdan ympärillä. Lisäksi täytyy määrittää kameran ja kuvan keskustan välinen vektori, kuvan leveys ja resoluutio. 

Kun tarvittavat parametrit on alustettu, voidaan camera-olio luoda. Kameran kuvaamiksi kentiksi asetetaan ainoastaan H2\_fraction. Lisäksi määritetään, että kuvassa näytetään ainoastaan aiemmin luodun 1 kpc säteisen pallon sisällä oleva aine, jolloin vältytään siltä riskiltä, että tutkittavan alan eteen tulee toinen huomattavasti molekulaarista vetyä sisältävä alue, joka estää tutkittavan alueen näkemisen.

Animaation luomiseksi käytetään kameran \texttt{zoomin}-funktiota, jolla on mahdollista iteroida haluttu zoomaus halutulla määrällä vakiokokoisia askelia. Esimerkin animaatiossa zoomauskertoimeksi on valittu 3 ja askelten määrä on valittu sellaiseksi, että kohde voidaan kiertää kerran 0,04 radiaanin askelin. Kierron toteuttamiseksi kameraa käännetään kunkin zoomauksen jälkeen. Tämän jälkeen \texttt{zoomin}-funktion palauttama kuva tallennetaan numeroituna.

%TODO ehkä siitä, että on suorituskyvyn kannalta oleellista käyttää yhtä kameraa ja kääntää ja liikuttaa sitä?

\subsection{Usean kuvaajan plotit}
\yt\ tarjoaa mahdollisuuden kuvaajien palauttamiseen taulukkona, jota voidaan edelleen käyttää esimerkiksi \texttt{matplotlib}in\footnote{\url{http://matplotlib.org/mpl_toolkits/axes_grid/api/axes_grid_api.html}} kanssa usean kuvaajan yhdistämiseksi samaan kuvaan. Tähän on kuitenkin myös apufunktio, jolle voidaan antaa suoraan joko kuvaajat tai jpg-kuvat, jotka asemoidaan haluttaessa väripalkkien kanssa ruudukkoon.

Liitteessä \ref{koodi:multiplot-simppeli} on nähtävillä \texttt{eps\_writer}iä hyödyntävä skripti, joka plottaa tiheyden ja lämpötilan 7 kpc leveällä alueella simulaation tiheimmän kohdan ympäriltä ja tallentaa ne sekä erikseen että yhdessä. Plotti, jossa molemmat ovat, on nähtävissä kuvassa \ref{fig:multiplot-simppeli}. Plotin muodostamista voidaan ohjata erilaisilla parametrina annettavilla lipuilla. Esimerkiksi kuvan \ref{fig:multiplot-simppeli} luomisessa on hyödynnetty parametreja \texttt{xaxis\_flags} ja \texttt{yaxis\_flags}, joilla asetetaan akselit plottien ulkoreunoille sekä parametria \texttt{cb\_location}, jolla väripalkit asetetaan kuvaajien yläpuolelle.

\begin{figure}
   \centering
   \includegraphics[width=\textwidth]{../kuvat/EPSMultiPlot.png}
   \caption{Liitteessä \ref{koodi:multiplot-simppeli} esitetyn skriptin tuottama kuva.} \label{fig:multiplot-simppeli}
\end{figure}

\subsubsection{Ongelmat}
\yt\ on kuitenkin vielä kehittyvä paketti, mikä on selvästi huomattavissa käyttämäni \yt -version 3.2 \texttt{eps\_writer}-luokassa. Kuvasta \ref{fig:multiplot-simppeli} nähdään esimerkiksi, että plotit eivät ole keskellä niille piirrettyjä reunuksia vaan liian alhaalla. Lisäksi mikäli esimerkiksi käytettyä väriskaalaa vaihdetaan, täytyy yksittäiset kuvat tallentaa ennen niiden käyttämistä multiplotissa. Jos esimerkiksi liitteen \ref{koodi:multiplot-simppeli} rivit 21 ja 30 kommentoidaan pois koodista, saadaan tuloksena kuva, jossa väripalkit noudattavat hot-colormappia mutta kuvat oletuksena käytettävää jet-väritystä.

Lisäksi dokumentaation \cite{multiplot-api} ja lähdekoodin \cite{multiplot-source} mukaan \texttt{eps\_writer} tukee myös profiileja. Esimerkiksi liitteen \ref{koodi:multiplot-nelikentta} skriptin ajaminen johtaa kuitenkin virheilmoitukseen "\texttt{Attribute\-Error: 'ProfilePlot' object has no attribute '\_redraw\_image'}" ohjelman suorituksen edettyä riville 85, jossa plotit yhdistetään. Yksittäiset kuvat tallentuvat kuitenkin normaalisti, mikä osoittaa skriptin alkuosan toimivan. Todennäköisesti \texttt{ProfilePlot}-luokkaa tai jotain muuta \yt :n osaa on muokattu, ja testien riittämättömän kattavuuden takia vaikutukset muualla koodissa ovat jääneet huomaamatta. \yt\ on kuitenkin avointa lähdekoodia, joten ongelman korjaaminen itse oli mahdollista.

%\textsc{Traceback (most recent call last):
%  File "multiplot-nelikentta.py", line 85, in <module>
%    multi = eps.multiplot(sarakkeet, rivit, plots, bare_axes=False, cb_labels=colorbar_label, cb_flags = colorbar_flags, xaxis_flags = xaxis_flags, yaxis_flags = yaxis_flags)
%  File "/data/scratch3/extragal/YT/yt-x86_64/src/yt-hg/yt/visualization/eps_writer.py", line 1120, in multiplot
%    field=fields[index])
%  File "/data/scratch3/extragal/YT/yt-x86_64/src/yt-hg/yt/visualization/eps_writer.py", line 505, in insert_image_yt
%    plot._redraw_image()
%AttributeError: 'ProfilePlot' object has no attribute '_redraw_image'}


\subsubsection{Muutokset \yt :n lähdekoodissa}
Virheilmoituksen perusteella ongelmakohdan paikantaminen oli hyvin yksinkertaista. Liitteen \ref{liite:muutokset} listingissä \ref{koodi:fig-orig} on esitetty ongelman aiheuttanut profiilien käsittelyyn kirjoitettu \texttt{eps\_writer}-luokan \texttt{insert\_image\_yt}-funktion osa, jonka on tarkoitus hakea multiplottiin lisättävä kuva ja poistaa profiilin tapauksessa tarpeeton väripalkki.

\texttt{ProfilePlot}-luokalla ei kuitenkaan ole \texttt{\_redraw\_image()}-funktiota, joten ohjelman suoritus keskeytyy. Myöskään \texttt{\_figure} ei ole määritelty. Sen sijaan \texttt{figures}-attribuuttiin on tallennettu \texttt{FigureContainer}, josta haluttu figure voidaan hakea. Lisäksi väripalkin poistaminen ei ole tarpeellista. Sama lohko näiden korjausten jälkeen on nähtävissä liitteen \ref{liite:muutokset} listingissä \ref{koodi:fig-uusi}.

Tämän lisäksi alkuperäisessä koodissa käytetään akselien rajojen, tekstien ja logaritmisuuden määrittämiseen samaa lohkoa sekä \texttt{ProfilePlot}- että \texttt{PhasePlot}-luokkien olioiden käsittelyyn. Sen käyttäminen profiileihin johtaa kuitenkin kaatumiseen. Siksi kirjoitin profiilien käsittelyyn oman, erillisen lohkonsa, joka on nähtävissä liitteen \ref{liite:muutokset} listingissä \ref{koodi:akselit}.

Lisäksi profiilien kanssa väripalkin käyttäminen ei ole koskaan mielekästä, joten lisäsin \texttt{colorbar\_yt}-funktioon tarkastuksen, jolla varmistetaan, ettei sitä käytetä profiilien kanssa. Mikäli käyttäjä yrittää tehdä näin, heitetään \texttt{RuntimeError} viestillä "When using ProfilePlots you must either set yt\_nocbar=True or provide colorbar flags so that the profiles don't have colorbars".

Näiden muutosten jälkeen liitteen \ref{koodi:multiplot-nelikentta} skripti voidaan ajaa virheettä. Kukin plotti täytyy edelleen tallentaa yksin, jotta plottiin tehdyt muutokset välittyvät luotavaan nelikenttään. Lisäksi \yt\ piirtää väripalkit niin kauas varsinaisista ploteista, että tarvittaessa väliin mahtuisi akselin selite. Koska sitä ei kuitenkaan tässä plotissa tarvita, muutin tätä plottia varten väripalkin sijoittelua määrääviä vakioita siten, että ne siirtyivät hieman lähemmäs plotteja. Tuloksena saatava nelikenttä on nähtävissä kuvassa \ref{fig:nelikentta}.

\begin{figure}
   \centering
   \includegraphics[width=\textwidth]{../kuvat/nelikko.png}
   \caption{Liitteessä \ref{koodi:multiplot-nelikentta} esitetyn skriptin tuottama kuva. Ylemmissä ploteissa on esitetty samalta alueelta säteilevän hiukkasen ympäristöstä vedyn lukumäärätiheyden projektio ja läpileikkaus molekulaarisen vedyn osuudesta. Näiden alla olevissa profiileissa on esitetty samat suureet profiileina, vedyn lukumäärätiheys keskitettynä simulaation tiheimpään kohtaan ja molekulaarisen vedyn osuus keskitettynä säteilylähteeseen.} \label{fig:nelikentta}
\end{figure}

Koodin toimivuuden testaamisen jälkeen loin pull requestin muutosteni sulauttamiseksi \yt :n kehitysversioon. Kokeneemmat kehittäjät arvioivat kaikki pull requestit ja joko ehdottavat parannuksia tai suoraan hyväksyvät tai hylkäävät requestin. Muutokseni hyväksyttiin, joten nyt ne ovat kaikkien käytettävissä  ja paranneltavissa. 

\section{Johtopäätökset}
\yt\ helpottaa simulaatiodatan visualisointia huomattavasti ja tekee visualisointien luomisesta intuitiivista ja vaivatonta. Tästä huolimatta on hyödyllistä ymmärtää ohjelman toimintaa jonkin verran, jotta plotteja ei esimerkiksi luo vahingossa tarpeettoman tehottomasti. Samoin simulaatiodatan ja niiden luomiseen käytettyn simulaatiokoodin tunteminen on hyödyllistä, jotta datasta voidaan valita kiinnostavat alueet ja datan erityispiirteet kuten esimerkiksi AMR-simulaatioiden tapauksessa paikan mukaan muuttuva resoluutio osataan ottaa huomioon.

Erilaisia plotteja on lukuisia, ja niiden joukosta kannattaa pyrkiä valitsemaan tutkittavan datan erityispiirteet parhaiten esille tuovat. Esimerkiksi läpileikkaus näyttää tarkasti yhden tason simulaatiosta, mutta kadottaa näkösäteen suuntaiset rakenteet, kun taas projektiolla on mahdollista tarkastella laajempia rakenteita, mutta niiden sijoittumista kolmiulotteisesti on mahdotonta nähdä. Plottityypin valinnan lisäksi myös parametrit kannattaa valita huolellisesti. Usein paras tapa tähän on tehdä runsaasti erilaisia kokeiluja muutellen arvoja.

Animaatiot tuovat usein simulaation piirteet yksittäisiä plotteja paremmin esiin. Erityisesti aikasarjoissa ja kolmiulotteisia rakenteita tutkittaessa animoinnista on hyötyä, sillä animaatiosta ajan kuluessa tapahtuvat muutokset on helpompi hahmottaa. Samoin yksittäinen 3D-renderöinti ei useinkaan anna kovin selkeää kuvaa kohteiden etäisyyksistä, mutta esimerkiksi kameran siirtäminen tai kääntäminen saa aikaan illuusion kolmiulotteisuudesta. Animaatioiden huonona puolena on kuitenkin yksittäisiin kuviin verrattuna hyvin suuri levytilan tarve ja framejen luomiseen kuluva aika.

Kaikenkaikkiaan \yt\ on hyvin lupaava apuväline ja kehitystyö jatkuu yhä sen parantamiseksi. Kuten {eps\_writer}in tapauksessa huomattiin, on joidenkin vähemmän käytettyjen ominaisuuksien toiminta vielä epävarmaa eivätkä esimerkiksi automaattiset testit kata kaikkea koodia. Ydinominaisuudet ovat kuitenkin luotettavia ja hyvin testattuja ja dokumentoituja.

Myös tämän työn tekemisen aikana tehdyt muutokset \yt :n lähdekoodiin päätyivät osaksi \yt :n kehitysversiota. Korjasin ongelman, jossa profiilien käyttäminen \texttt{eps\_writer}in kanssa johti ohjelman kaatumiseen ja tein muutoksistani pull requestin. Se hyväksyttiin muutoksitta, joten nyt parannukseni ovat kaikkien käytettävissä.

%%%%% Sisältö loppuu, lähdeluettelo %%%%%
\bibliographystyle{plain}
\small
\bibliography{lahteet} %TODO yt api on pienellä

\appendix
%\newpage
%\section{Läpilento} \label{koodi:kaanto-projection}
%\lstinputlisting[style=python]{../python/flythrough.py}
%\newpage
\section{3D-animaatio spiraaliradalla kohdetta lä\-hes\-tyen} \label{koodi:volume-spiraali}
\lstinputlisting[style=python]{../python/volume-spiraali.py}
\newpage

\section{Kaksi läpileikkausta samassa plotissa} \label{koodi:multiplot-simppeli}
\lstinputlisting[style=python]{../python/multiplot-simppeli.py}
\newpage

\section{Nelikenttä} \label{koodi:multiplot-nelikentta}
\lstinputlisting[style=python]{../python/multiplot-nelikentta.py}
\newpage


\section{\yt:n lähdekoodin muutokset} \label{liite:muutokset}

\begin{minipage}{\textwidth}
\lstset{style=python, caption={Alkuperäinen profiilin hakemiseen käytetty koodinpätkä.}, label={koodi:fig-orig}}
\begin{lstlisting}
elif isinstance(plot, ProfilePlot):
	plot._redraw_image()
	# Remove colorbar
	_p1 = plot._figure
	_p1.delaxes(_p1.axes[1])
\end{lstlisting}
\end{minipage}

\begin{minipage}{\textwidth}
\lstset{style=python, caption={Korjattu ohjelmanpätkä, joka korvaa listingin \ref{koodi:fig-orig} koodin.}, label={koodi:fig-uusi}}
\begin{lstlisting}
elif isinstance(plot, ProfilePlot):
	_p1 = plot.figures.items()[0][1]
\end{lstlisting}
\end{minipage}

\lstinputlisting[style=python, caption={Profiilin akselien rajojen, tekstien ja logaritmisuuden asettamiseksi \texttt{eps\_writer}-luokkaan lisätty koodi.}, label={koodi:akselit}]{../python/akselit-korjaus.py}

\end{document}